
/*struct EPAFace {
    float distance;
    Vector3 normal;
    unsigned simplex_index;
}

static void simplex_insert(Simplex* s, const Vector3& v, unsigned idx)
{
    if (idx == s->size)
    {
        s[idx] = v;
        ++s->size;
        return;
    }

    memmove(s->vertices + idx + 1, s->vertices + idx, sizeof(Vector3) * (s->size - idx));
    s[idx] = v;
    ++s->size;
}

static EPAFace find_closest_face(const Simplex& s)
{
    EPAFace closest = {};
    closest.distance = FLT_MAX;

    for (unsigned i = 0; i < s.size; ++i)
    {
        int j = ((i + 1) == s.size) ? 0 : i + 1;
        int k = ((k + 1) == s.size) ? 0 : k + 1;
        Vector3 A = s.vertices[i];
        Vector3 B = s.vertices[j];
        Vector3 C = s.vertices[k];

        Vector3 AB = B - A;
        Vector3 AC = C - A;
        Vector3 OA = -A;
        Vector3 ABC = vector3_cross(AB, vector3_cross(OA, AB))
    }
}

static Vector3 run_epa(const GJKShape& s1, const GJKShape& s2, Simplex* s)
{
    while(true)
    {
        Vector3 f = find_closest_face(s);
        Vector3 d = support(s1, s2, f.normal);
        float depth = vector3_dot(d, f.normal);

        if (almost_equal(depth, f.distance))
            return f.normal * depth;

        simplex_insert(s, d, f.simplex_index);
    }
}

Vector3 gjk_epa_intersect_and_solve(const GJKShape& s1, const GJKShape& s2)
{
    GJKResult res = run_gjk(s1, s2);

    if (!res.collsion)
        return {0, 0, 0};

    return run_epa(s1, s2, &res.simplex);
}*/


static Vector3 get_spherical_coords(unsigned lat_number, unsigned long_number, unsigned latitude_bands, unsigned longitude_bands)
{
    float theta = lat_number * PI / latitude_bands;
    float sin_theta = sinf(theta);
    float cos_theta = cosf(theta);

    float phi = long_number * 2 * PI / longitude_bands;
    float sin_phi = sinf(phi);
    float cos_phi = cosf(phi);

    float x = cos_phi * sin_theta;
    float y = cos_theta;
    float z = sin_phi * sin_theta;

    return { x, y, z };
}

static Mesh create_sphere(float radius)
{
    unsigned latitude_bands = 16;
    unsigned longitude_bands = latitude_bands;
    Mesh m = {};
    m.num_vertices = (latitude_bands - 1)*longitude_bands + 2;
    m.num_indices = (latitude_bands - 2)*longitude_bands * 6 + 2*longitude_bands*3;
    m.vertices = (Vertex*)zalloc_zero(m.num_vertices * sizeof(Vertex));
    m.indices = (unsigned*)zalloc_zero(m.num_indices * sizeof(unsigned));
    unsigned cur_vertex = 0;
    unsigned cur_index = 0;

    Vector3 top_coord{0, 1, 0};
    m.vertices[0].position = top_coord * radius;
    m.vertices[0].normal = top_coord;
    m.vertices[0].color = color_random();
    ++cur_vertex;

    for (unsigned long_number = 0; long_number < longitude_bands; long_number++)
    {
        m.indices[cur_index] = 0;

        if (long_number + 2 > longitude_bands)
        {
            m.indices[cur_index + 1] = 1;
            m.indices[cur_index + 2] = longitude_bands;
        }
        else
        {
            m.indices[cur_index + 1] = long_number + 2;
            m.indices[cur_index + 2] = long_number + 1;
        }
        
        cur_index += 3;
    }

    for (unsigned lat_number = 1; lat_number < latitude_bands; lat_number++)
    {
        for (unsigned long_number = 0; long_number < longitude_bands; long_number++)
        {
            Vector3 coords = get_spherical_coords(lat_number, long_number, latitude_bands, longitude_bands);
            m.vertices[cur_vertex].position = coords * radius;
            m.vertices[cur_vertex].normal = coords;
            m.vertices[cur_vertex].color = color_random();

            if (lat_number == latitude_bands - 1)
            {
                if (long_number == longitude_bands - 1)
                {
                    m.indices[cur_index] = cur_vertex;
                    m.indices[cur_index + 1] = cur_vertex - longitude_bands + 1;
                    m.indices[cur_index + 2] = m.num_vertices - 1;
                }
                else
                {
                    m.indices[cur_index] = cur_vertex;
                    m.indices[cur_index + 1] = cur_vertex + 1;
                    m.indices[cur_index + 2] = m.num_vertices - 1;
                }

                cur_index += 3;
            }
            else
            {
                if (long_number == longitude_bands - 1)
                {
                    m.indices[cur_index] = cur_vertex;
                    m.indices[cur_index + 1] = cur_vertex - longitude_bands + 1;
                    m.indices[cur_index + 2] = cur_vertex + longitude_bands;
                    m.indices[cur_index + 3] = cur_vertex - longitude_bands + 1;
                    m.indices[cur_index + 4] = cur_vertex + 1;
                    m.indices[cur_index + 5] = cur_vertex + longitude_bands;
                }
                else if (lat_number < latitude_bands - 1)
                {
                    m.indices[cur_index] = cur_vertex;
                    m.indices[cur_index + 1] = cur_vertex + 1;
                    m.indices[cur_index + 2] = cur_vertex + longitude_bands;
                    m.indices[cur_index + 3] = cur_vertex + 1;
                    m.indices[cur_index + 4] = cur_vertex + longitude_bands + 1;
                    m.indices[cur_index + 5] = cur_vertex + longitude_bands;
                }

                cur_index += 6;
            }
            cur_vertex += 1;
        }
    }


    Vector3 bottom_coord{0, -1, 0};
    m.vertices[m.num_vertices - 1].position = bottom_coord * radius;
    m.vertices[m.num_vertices - 1].normal = bottom_coord;
    m.vertices[m.num_vertices - 1].color = color_random();
    ++cur_vertex;

    Assert(cur_vertex == m.num_vertices, "Num vertices does not match in sphere creation.");
    Assert(cur_index == m.num_indices, "Num indices does not match in sphere creation.");

    return m;
}