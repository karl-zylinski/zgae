### IMPORTANT ###

- move input layout into pipeline file etc
    * rename "input layout" to "vertex input" or "vertex input layout" everywhere
    * make sure constant buffer updating is purdy

- add render world and draw_world or sumth

### LESS IMPORTANT ###

- put renderer on own thread

- look at functions and maybe inline those that are just called once

- alpha support (something else than VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR)

- rename shader.c and pipeline.c to ##-intermediate.c

- rewrite obj loader, its ugly

- make first-person flying camera (see avatar.lua)

- combine linux_main and linux_xcb_window into main_linux_xcb_vulkan

- make renderer askable about source type, i.e. have shader_default_fragment as source string, and append whatever renderer tells us to do... or maybe just have a source_spirv field and ask renderer which field to pull, like with a SHADER_LANGAUGE_TYPE enum in the renderer

- in shader in parser, error if > 1 shader of a type

- add library shader compiler or invoke commandline shader compiler (so we can use glsl)

- make some kind of resource thing, one corresponding to each resource on disk (shader, pipeline etc). remove the intermediate structs nad use those instead, pass them to renderer. have a central resource lut so files arent loaded twice. later maybe we make resource that is compiled into just a struct and then loaded quickly (i.e. shader resource -> compile -> shader -> renderer loads shader, not a shader resource)

- handles:
    i = index
    t = type --- unique identifier per-pool (have a handle_types_t enum with stuff like HANDLE_TYPE_RENDERER_RESOURCE or HANDLE_TYPE_SCRIPT_RESOURCE (should we then skip the typedeffed RendererResourceHandle ?????? or maybe its nice syntactic sugar))
    s = subtype --- added to pool, i.e. renderer_resource_type_t which has values like RENDERER_RESOURCE_TYPE_SHADER or SCRIPT_RESOURCE_ENTITY
    u = used

    iiiiiiii iiiiiiii iiiiiiii iiiiiiii iiiiiiii tttttttt ssssssss sssssssu

    or perhaps (maybe go with this, we can change later if we want to)

    iiiiiiii iiiiiiii iiiitttt sssssssu

    then we can, from a handle, find any type and and the subtype and thus tell the scripting thing what we actually have,
    like doing nice type checks --- but maybe we should have an enum list for type, so we can do quick check against it?
    so when we init a handle pool we tell it which type it is, and then add subtypessss

- array: make array_internal_ensure_min_size func use array_internal_grow with capacity parameter