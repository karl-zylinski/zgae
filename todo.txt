- shader:
    * make renderer askable about source type, i.e. have shader_default_fragment as source string, and append whatever renderer tells us to do... or maybe just have a source_spirv field and ask renderer which field to pull, like with a SHADER_LANGAUGE_TYPE enum in the renderer
    * in parser, error if > 1 shader of a type

- indexed drawing

- swapchain recreate (check both xcb event and also returncode for from vkAcquireNextImageKHR and vkQueuePresentKHR)

- split renderer into renderer and renderer_backend, with renderer_backend being impleneted as renderer_backend_vulkan

- add library shader compiler or invoke commandline shader compiler (so we can use glsl)

- handles:
    i = index
    t = type --- unique identifier per-pool (have a handle_types_t enum with stuff like HANDLE_TYPE_RENDERER_RESOURCE or HANDLE_TYPE_SCRIPT_RESOURCE (should we then skip the typedeffed renderer_resource_handle_t ?????? or maybe its nice syntactic sugar))
    s = subtype --- added to pool, i.e. renderer_resource_type_t which has values like RENDERER_RESOURCE_TYPE_SHADER or SCRIPT_RESOURCE_ENTITY
    u = used

    iiiiiiii iiiiiiii iiiiiiii iiiiiiii iiiiiiii tttttttt ssssssss sssssssu

    or perhaps (maybe go with this, we can change later if we want to)

    iiiiiiii iiiiiiii iiiitttt sssssssu

    then we can, from a handle, find any type and and the subtype and thus tell the scripting thing what we actually have,
    like doing nice type checks --- but maybe we should have an enum list for type, so we can do quick check against it?
    so when we init a handle pool we tell it which type it is, and then add subtypessss

- array: make array_internal_ensure_min_size func use array_internal_grow with capacity parameter