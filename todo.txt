- shader:
    * have one constant buffer per swapchain image, i.e. 2 constant buffers per binding
        * add semaphore for rendering like in vulkan tutorial
    * make func to populate constant buffers (per field name maybe???? or maybe by idx)

    * make renderer askable about source type, i.e. have shader_default_fragment as source string, and append whatever renderer tells us to do... or maybe just have a source_spirv field and ask renderer which field to pull, like with a SHADER_LANGAUGE_TYPE enum in the renderer
    * in parser, error if > 1 shader of a type




- add geometry loading (do vertex buffer stuff as in xcb_vulkan.c)

- add draw func that takes pipeline handle and geometry handle (are constant buffs set separately? check old renderer)

- make simple xcb -> key_t mapping, just bash keys and record into an enum!

- handles:
    i = index
    t = type --- unique identifier per-pool (have a handle_types_t enum with stuff like HANDLE_TYPE_RENDERER_RESOURCE or HANDLE_TYPE_SCRIPT_RESOURCE (should we then skip the typedeffed renderer_resource_handle_t ?????? or maybe its nice syntactic sugar))
    s = subtype --- added to pool, i.e. renderer_resource_type_t which has values like RENDERER_RESOURCE_TYPE_SHADER or SCRIPT_RESOURCE_ENTITY
    u = used

    iiiiiiii iiiiiiii iiiiiiii iiiiiiii iiiiiiii tttttttt ssssssss sssssssu

    or perhaps (maybe go with this, we can change later if we want to)

    iiiiiiii iiiiiiii iiiitttt sssssssu

    then we can, from a handle, find any type and and the subtype and thus tell the scripting thing what we actually have,
    like doing nice type checks --- but maybe we should have an enum list for type, so we can do quick check against it?
    so when we init a handle pool we tell it which type it is, and then add subtypessss

- array: make array_internal_ensure_min_size func use array_internal_grow with capacity parameter